//+build ignore

// Small program to generate imx6sx iomuxc xxx.go and xxxx.go.
//
package main

import (
	"bytes"
	"fmt"
	"go/format"
	_ "io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
)

var urls = map[string]string{
	"imx6sx-pinfunc": "https://raw.githubusercontent.com/torvalds/linux/master/arch/arm/boot/dts/imx6sx-pinfunc.h",
}

func main() {
	for name, url := range urls {
		write(name, url)
	}
}

func write(name, url string) {
	resp, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	//	data, err := ioutil.ReadAll(resp.Body)
	//	if err != nil {
	//		log.Fatalf("error reading %q: %v", url, err)
	//	}

	// ...so we convert it to a string by passing it through
	// a buffer first. A 'costly' but useful process.
	buf := new(bytes.Buffer)
	buf.ReadFrom(resp.Body)
	newStr := buf.String()

	w := new(bytes.Buffer)

	//fmt.Fprint(w, "//+build ignore\n\n\n")
	fmt.Fprint(w, "// GENERATED BY mkiomuxc_ignore.go  DONT EDIT IT\n\n")
	fmt.Fprint(w, "package udoo\n\n")

	pincrl := `	      
	/*
	 * The pin function ID is a tuple of
	 * <mux_reg conf_reg input_reg mux_mode input_val>
	 */
	type PinCrtl struct {
		//id       string
		muxReg   uint //mux控制寄存器偏移地址
		confReg  uint //pad控制寄存器偏移地址
		inputReg uint //select_input控制寄存器偏移地址
		muxMode  uint //mux模式
		inputVal uint //select_input寄存器值
	}

	type GpioPin struct {
		n     int
		aliay string
		crl   PinCrtl
		//padctrlOft uint32
		//muxOft     uint32
	}
`

	fmt.Fprintf(w, pincrl)

	fmt.Fprintf(w, "// %s \n", name)

	fmt.Fprintf(w, outputPinCrtlVar(newStr))
	fmt.Fprintf(w, outputGpioPinVar(newStr))

	wbytes := w.Bytes()
	b, err := format.Source(wbytes)
	if err != nil {
		os.Stderr.Write(wbytes)
		log.Fatalf("error formatting: %v", err)
	}
	f, err := os.Create(name + ".go")
	if err != nil {
		log.Fatal(err)
	}
	if _, err := f.Write(b); err != nil {
		log.Fatal(err)
	}
	if err := f.Close(); err != nil {
		log.Fatal(err)
	}

}

func outputPinCrtlVar(inputStr string) (str string) {
	str = "\n\n const (\n"

	lines := strings.Split(inputStr, ("\n"))
	for _, line := range lines {
		fields := strings.Fields(line)
		if len(fields) < 7 {
			continue
		}
		//  0           1                                                    2     3      4      5   6
		//#define MX6SX_PAD_GPIO1_IO00__I2C1_SCL                            0x0014 0x035C 0x07A8 0x0 0x1
		prex := strings.TrimSpace(fields[0])
		b := (prex == ("#define"))
		if b == false {
			continue
		}

		id := strings.TrimSpace(fields[1])
		muxReg := strings.TrimSpace(fields[2])
		confReg := strings.TrimSpace(fields[3])
		inputReg := strings.TrimSpace(fields[4])
		muxMod := strings.TrimSpace(fields[5])
		inputVal := strings.TrimSpace(fields[6])
		str += fmt.Sprintf("%s  =PinCrtl{ muxReg:%s,confReg:%s,inputReg:%s,muxMode:%s,inputVal:%s, }\n", id, muxReg, confReg, inputReg, muxMod, inputVal)
	}
	str += ")"
	return str
}

func outputGpioPinVar(inputStr string) (str string) {
	str = "\n\n const (\n"

	lines := strings.Split(inputStr, ("\n"))
	for _, line := range lines {
		fields := strings.Fields(line)
		if len(fields) < 7 {
			continue
		}
		//  0           1                                                    2     3      4      5   6
		//#define MX6SX_PAD_GPIO1_IO00__GPIO1_IO_0                          0x0014 0x035C 0x0000 0x5 0x0
		prex := strings.TrimSpace(fields[0])
		b := (prex == ("#define"))
		if b == false {
			continue
		}

		id := strings.TrimSpace(fields[1])
		ids := strings.Split(id, ("__"))
		if len(ids) != 2 {
			continue
		}
		aliay := strings.TrimSpace(ids[1])
		if i := strings.Index(aliay, "GPIO"); i != 0 {
			continue
		}

		//analyze GPIO1_IO_0 format
		gpios := strings.Split(aliay, ("_"))
		if len(gpios) != 3 {
			continue
		}
		t := gpios[0]
		bank, err := strconv.ParseUint(t[4:], 10, 32)
		if err != nil {
			continue
		}
		num, err := strconv.ParseUint(gpios[2], 10, 32)
		if err != nil {
			continue
		}

		str += fmt.Sprintf("%s =  GpioPin{n:%d, aliay: \"%s\", crl: %s} \n", aliay, (bank-1)*32+num, aliay, id)

	}
	str += ")"
	return str
}

/*

var pins = [...]GpioPin{
	GpioPin{n: 0, aliay: "GPIO1_IO00", crl: MX6SX_PAD_GPIO1_IO00__GPIO1_IO_0}, //padctrl code ref P283, pad mux reg mem offset ref p1691



*/
